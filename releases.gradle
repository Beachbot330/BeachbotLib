task javaSourceJar(type: Jar) {
    description = 'Generates the source jar for java'
    group = 'WPILib'
    baseName = libraryName
    classifier = "sources"
    duplicatesStrategy = 'exclude'
    destinationDir = releaseDir
    
    if (useDriver) {
        dependsOn project(':arm:driver').classes
        from project(':arm:driver').sourceSets.main.allJava
    } else {
        dependsOn project(':arm:cpp').classes
        from project(':arm:cpp').sourceSets.main.allJava
    }  
}

task javaJavadocJar(type: Jar) {
    description = 'Generates the javadoc jar for java'
    group = 'WPILib'
    baseName = libraryName
    classifier = "javadoc"
    duplicatesStrategy = 'exclude'
    destinationDir = releaseDir
    
    if (useDriver) {
        dependsOn project(':arm:driver').javadoc
        from project(':arm:driver').javadoc.destinationDir
    } else {
        dependsOn project(':arm:cpp').javadoc
        from project(':arm:cpp').javadoc.destinationDir
    }  
}

task userSharedZip(type: Zip) {
    description = 'Creates user zip of libraries, with shared c++ libs.'
    group = 'WPILib'
    destinationDir = releaseDir
    baseName = libraryName
    classifier = 'usershared'
    duplicatesStrategy = 'exclude'
    
    // Copy include files from cpp project
    from(file(cppInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }

    // Copy shared binaries from cpp project
    project(':arm:cpp').model {
        binaries {
            withType(SharedLibraryBinarySpec) { binary ->
                from(binary.sharedLibraryFile) {
                    include '*.so'
                    into '/cpp/lib'
                }
                def debugFile = new File(binary.sharedLibraryFile.absolutePath + ".debug")
                  from(debugFile) {
                      include '*.so.debug'
                      into '/cpp/lib'
                  }
            }
        }
    }

    // copy driver include
    from (file(driverInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }
    
    // Copy included driver library headers
    from(file(driverLibraryInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }
    
    // Copy included driver library binaries
    from(file(driverLibraryLib)) {
        include '*.so*'
        include '*.a*'
        into '/cpp/lib'
    }
    
    // Copy included driver library headers
    from(file(cppLibraryInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }
    
    // Copy included driver library binaries
    from(file(cppLibraryLib)) {
        include '*.so*'
        include '*.a*'
        into '/cpp/lib'
    }

    // Include java jar
    if (useDriver) {
        def javaProject = project(':arm:driver')
        dependsOn javaProject.jar
        // Copy project java binary
        from (file(javaProject.jar.archivePath)) {
            into '/java/lib'
        } 
    } else {
        def javaProject = project(':arm:cpp')
        dependsOn javaProject.jar
        // Copy project java binary
        from (file(javaProject.jar.archivePath)) {
            into '/java/lib'
        }
    } 
    
    // Copy shared binaries from driver project for java
    if (useDriver) {
        project(':arm:driver').model {
            binaries {
                withType(SharedLibraryBinarySpec) { binary ->
                    from(binary.sharedLibraryFile) {
                        include '*.so'
                        into '/java/lib'
                    }
                    def debugFile = new File(binary.sharedLibraryFile.absolutePath + ".debug")
                      from(debugFile) {
                          include '*.so.debug'
                          into '/java/lib'
                      }
                }
            }
        }
    }
    
    // If not embedded java, include java libs
    if (!embedJavaLibraries) {
        from(file(javaLibraryLoc)) {
            include '*.jar'
            include '*.so'
            include '*.so.debug'
            into '/java/lib'
        }
    }

    // Include java sources if set
    if (includeJavaSources) {
      dependsOn javaSourceJar
        from (file(javaSourceJar.archivePath)) {
            into '/java/src'
        }
    }
    
    // Include java javadoc if set
    if (includeJavaJavadoc) {
        dependsOn javaJavadocJar
        from (file(javaJavadocJar.archivePath)) {
            into '/java/src'
        }
    }
    
    // Include cpp sources if set
    if (includeCppSources) {
        from(file(cppSrc)) {
            include '**/*.cpp'
            include '**/*.h'
            into "/cpp/src/$libraryName"
        }
    }
    
    // Include driver sources if set
    if (includeDriverSources) {
        from(file(driverSrc)) {
            include '**/*.cpp'
            include '**/*.h'
            into "/cpp/src/$libraryName"
        }
    }
}

task userStaticZip(type: Zip) {
    description = 'Creates user zip of libraries, with static c++ libs.'
    group = 'WPILib'
    destinationDir = releaseDir
    baseName = libraryName
    classifier = 'userstatic'
    duplicatesStrategy = 'exclude'
    
    // Copy include files from cpp project
    from(file(cppInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }

    // Copy static binaries from cpp project
    project(':arm:cpp').model {
        binaries {
            withType(StaticLibraryBinarySpec) { binary ->
                from(binary.staticLibraryFile) {
                    include '*.a'
                    into '/cpp/lib'
                }
            }
        }
    }

    // copy driver include
    from (file(driverInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }
    
    // Copy included driver library headers
    from(file(driverLibraryInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }
    
    // Copy included driver library binaries
    from(file(driverLibraryLib)) {
        include '*.so*'
        include '*.a*'
        into '/cpp/lib'
    }
    
    // Copy included driver library headers
    from(file(cppLibraryInclude)) {
        include '**/*.h'
        into '/cpp/include'
    }
    
    // Copy included driver library binaries
    from(file(cppLibraryLib)) {
        include '*.so*'
        include '*.a*'
        into '/cpp/lib'
    }

    // Include java jar
    if (useDriver) {
        def javaProject = project(':arm:driver')
        dependsOn javaProject.jar
        // Copy project java binary
        from (file(javaProject.jar.archivePath)) {
            into '/java/lib'
        } 
    } else {
        def javaProject = project(':arm:cpp')
        dependsOn javaProject.jar
        // Copy project java binary
        from (file(javaProject.jar.archivePath)) {
            into '/java/lib'
        }
    }
    
    // Copy shared binaries from driver project for java
    if (useDriver) {
        project(':arm:driver').model {
            binaries {
                if (!combineStaticLibs) {
                    withType(StaticLibraryBinarySpec) { binary ->
                        from(binary.staticLibraryFile) {
                            include '*.a'
                            into '/cpp/lib'
                        }
                    }
                }
                withType(SharedLibraryBinarySpec) { binary ->
                    from(binary.sharedLibraryFile) {
                        include '*.so'
                        into '/java/lib'
                    }
                    def debugFile = new File(binary.sharedLibraryFile.absolutePath + ".debug")
                      from(debugFile) {
                          include '*.so.debug'
                          into '/java/lib'
                      }
                }
            }
        }
    }
    
    // If not embedded java, include java libs
    if (!embedJavaLibraries) {
        from(file(javaLibraryLoc)) {
            include '*.jar'
            include '*.so'
            include '*.so.debug'
            into '/java/lib'
        }
    }

    // Include java sources if set
    if (includeJavaSources) {
      dependsOn javaSourceJar
        from (file(javaSourceJar.archivePath)) {
            into '/java/src'
        }
    }
    
    // Include java javadoc if set
    if (includeJavaJavadoc) {
        dependsOn javaJavadocJar
        from (file(javaJavadocJar.archivePath)) {
            into '/java/src'
        }
    }
    
    // Include cpp sources if set
    if (includeCppSources) {
        from(file(cppSrc)) {
            include '**/*.cpp'
            include '**/*.h'
            into "/cpp/src/$libraryName"
        }
    }
    
    // Include driver sources if set
    if (includeDriverSources) {
        from(file(driverSrc)) {
            include '**/*.cpp'
            include '**/*.h'
            into "/cpp/src/$libraryName"
        }
    }
}

task cppSources(type: Zip) {
    description = 'Creates a zip of cpp sources.'
    group = 'WPILib'
    destinationDir = releaseDir
    baseName = libraryName
    classifier = 'cppsources'
    duplicatesStrategy = 'exclude'
    
    from(cppSrc) {
        into 'src'
    }

    from(cppInclude) {
        into 'include'
    }
}

if (useDriver) {
    task driverSources(type: Zip) {
        description = 'Creates a zip of driver sources.'
        group = 'WPILib'
        destinationDir = releaseDir
        baseName = libraryName
        classifier = 'driversources'
        duplicatesStrategy = 'exclude'
        
        from(driverSrc) {
            into 'src'
        }

        from(driverInclude) {
            into 'include'
        }
    }
}

project(':arm:cpp').tasks.whenTaskAdded { task ->
    def name = task.name.toLowerCase()
    if (name.contains("sharedlibrary") || name.contains("staticlibrary")) {
        userSharedZip.dependsOn task
        userStaticZip.dependsOn task
    }
}

if (useDriver) {
    project(':arm:driver').tasks.whenTaskAdded { task ->
        def name = task.name.toLowerCase()
        if (name.contains("sharedlibrary") || name.contains("staticlibrary")) {
            userSharedZip.dependsOn task
            userStaticZip.dependsOn task
        }
    }
}

// Ensure that the WPILibVersioningPlugin is setup by setting the release type, if releaseType wasn't
// already specified on the command line
if (!hasProperty('releaseType')) {
    WPILibVersion {
        releaseType = 'official'
    }
}

def versionClass = """
package org.usfirst.frc330.util;
/*
 * Autogenerated file! Do not manually edit this file. This version is regenerated
 * any time the publish task is run, or when this file is deleted.
 */
public final class BeachbotLibVersion {
  public static final String Version = "${WPILibVersion.version}";
}
""".trim()

def wpilibVersionFile = file('java/src/org/usfirst/frc330/util/BeachbotLibVersion.java')

def willPublish = false
gradle.taskGraph.addTaskExecutionGraphListener { graph ->
    willPublish = graph.hasTask(build)
}

task generateJavaVersion() {
    description = 'Generates the BeachbotLib version class.'
    group = 'WPILib'

    // We follow a simple set of checks to determine whether we should generate a new version file:
    // 1. If the release type is not development, we generate a new verison file
    // 2. If there is no generated version number, we generate a new version file
    // 3. If there is a generated build number, and the release type is development, then we will
    //    only generate if the publish task is run.
    doLast {
        if (!WPILibVersion.releaseType.toString().equalsIgnoreCase('official') && !willPublish && wpilibVersionFile.exists()) {
            return
        }
        println "Writing version ${WPILibVersion.version} to $wpilibVersionFile"

        if (wpilibVersionFile.exists()) {
            wpilibVersionFile.delete()
        }
        wpilibVersionFile.write(versionClass)
    }
}

build.dependsOn generateJavaVersion
build.dependsOn javaSourceJar
build.dependsOn javaJavadocJar
build.dependsOn userSharedZip
build.dependsOn userStaticZip
build.dependsOn cppSources
if (useDriver) {
    build.dependsOn driverSources
}
